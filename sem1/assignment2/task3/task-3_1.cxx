/****************************************************************************
Даны неотрицательные целые числа n,k и массив целых чисел из [0..10^9] размера
n. Требуется найти k-ю порядковую статистику. т.е. напечатать число, которое
бы стояло на позиции с индексом k (0..n-1) в отсортированном массиве.
Напишите нерекурсивный алгоритм.

Требования к дополнительной памяти: O(n). Требуемое среднее время работы: O(n).

Функцию Partition следует реализовывать методом прохода двумя итераторами
в одном направлении. Описание для случая прохода от начала массива к концу:

- Выбирается опорный элемент. Опорный элемент меняется с последним элементом массива.
- Во время работы Partition в начале массива содержатся элементы, не бОльшие опорного.
  Затем располагаются элементы, строго бОльшие опорного. В конце массива лежат
  нерассмотренные элементы. Последним элементом лежит опорный.
- Итератор (индекс) i указывает на начало группы элементов, строго бОльших опорного.
- Итератор j больше i, итератор j указывает на первый нерассмотренный элемент.
- Шаг алгоритма. Рассматривается элемент, на который указывает j.
  Если он больше опорного, то сдвигаем j.
  Если он не больше опорного, то меняем a[i] и a[j] местами, сдвигаем i и сдвигаем j.
- В конце работы алгоритма меняем опорный и элемент, на который указывает итератор i.

           i,j
      а)  ▐ 2 │ 8 │ 7 │ 1 │ 3 │ 5 │ 6 ▐ 4 │
      
               i,j
      б)  ▐ 2 ▐ 8 │ 7 │ 1 │ 3 │ 5 │ 6 ▐ 4 │
      
                i   j
      в)  │ 2 ▐░8░▐ 7 │ 1 │ 3 │ 5 │ 6 ▐ 4 │

                i       j
      г)  │ 2 ▐░8░│░7░▐ 1 │ 3 │ 5 │ 6 ▐ 4 │

                    i       j
      д)  │ 2 │ 1 ▐░7░│░8░▐ 3 │ 5 │ 6 ▐ 4 │

                        i       j
      е)  │ 2 │ 1 │ 3 ▐░8░│░7░▐ 5 │ 6 ▐ 4 │

                        i           j
      ж)  │ 2 │ 1 │ 3 ▐░8░│░7░│░5░▐ 6 ▐ 4 │

                        i               j
      з)  │ 2 │ 1 │ 3 ▐░8░│░7░│░5░│░6░▐ 4 │

                        i
      и)  │ 2 │ 1 │ 3 ▐ 4 ▐░7░│░5░│░6░│░8░▐

****************************************************************************/

/****************************************************************************
Задача 3_1.

Реализуйте стратегию выбора опорного элемента "медиана трёх".
Функцию Partition реализуйте методом прохода двумя итераторами от начала
массива к концу.
****************************************************************************/

//Created by Yaishenka
//Copyright © 2017 Yaishenka. All rights reserved.
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <cmath>

using namespace std ;

int Partition (int* arr,int n) {
    int bas=n-1;
    swap(arr[n/2], arr[bas]);
    int i(0),j(0);
    while (j<n-1) {
        if (arr[j]>arr[bas]) {
            j+=1;
        } else {
            swap (arr[i],arr[j]);
            i+=1;
            j+=1;
        }
    }
    swap (arr[i],arr[bas]);
    return i;
}
int ordstat (int*arr,int n,int k) {
    int left(0),right=n;
    while (true) {
        int j=Partition(arr+left, right-left);
        j+=left;
        //cout<<"j: "<<j<<" left "<<left<<" right "<<right<<endl;
        //for (int i(0);i<n;++i) {
        //    cout<<arr[i]<<" ";
        //}
        //cout<<endl;
        if (k<j) {
            right=j;
        } else if (k>j) {
            left=j+1;
            
        } else {
            return arr[k];
        }
    }
}
int main () {
    int n,k;
    cin>>n>>k;
    int arr[n];
    for (int i(0);i<n;++i) {
        cin>>arr[i];
    }
    cout<<ordstat(arr, n, k);
    return 0;
}










